<Formatting in the BASIC Language>
BASIC programs can be written in line number format, label format, or a mixture of the two. The specifications are described below.

<Available variable types>
The available variable types are 32-bit signed integer (-2147483648 to +2147483647), 32-bit floating-point, and string. The end of the string is appended with 0x00.

Twenty-six integer type variables (A-Z) are available. To treat a variable as a floating-point type, write it as A#, and to treat it as a string, write it as A$. However, A (integer type), A# (floating-point type), and A$ (string type) cannot be used simultaneously.

Variables with long names (even longer names are allowed in Type P) of up to 6 characters can be used if specified with a statement such as USEVAR. The first letter of the name can be an alphabetic character (A-Z) or an underscore (_), and the second letter can be a number (0-9).

Integer type constants are written in decimal notation; if you use hexadecimal notation, you must either add a "$" to the beginning, such as "$1200", or write it as "0x1200".

Floating-point constants should be written as "2e-3" (for 0.002) or "10.5".

String type constants should be written by enclosing them with " ". When "" is used, it can be written as "CHR$($22)".

<General Instructions>
Hereinafter, x, y, z, etc. refer to integer values; x$, y$, z$ refer to character strings; x#, y#, z# refer to floating-point real values; xxx, yyy, zzz, www, etc. refer to arbitrary statements; x#, y#, z# refer to floating-point real values; x#, y#, z#, etc. refer to floating-point real values. [ ] indicates that the statement is optional. | (vertical line) indicates that either left or right notation can be used.

Multiple commands can be processed on a single line by separating them with ":".

BGCOLOR r,g,b
	Specifies background color.
BREAK
	Breaks out of FOR-NEXT, DO-LOOP, and WHILE-WEND loops.
CDATA x[,y[,z[...]]]
	Specify data sequence as 8-bit integer value.
CLEAR
	Discard all string-type variables and integer-type arrays, and set integer values to 0. Also, stop using PCG and reset the display character.
CLS
	Clear screen.
COLOR x
	Specifies text color.
CONTINUE
	Skip subsequent code in FOR-NEXT, DO-LOOP, and WHILE-WEND loops.
CURSOR x,y
	Specifies cursor position.
CDATA xxx[,yyy[,zzz[...]]]
	Specify data sequence as 8-bit integer value.
DATA xxx[,yyy[,zzz[...]]]]
	Specify a data string as an integer value or a string.
DELAYMS x
	Available for Type P. Stop execution for x milliseconds.
DELAYUS x
	Available for Type P. Stop execution for x microseconds.
DIM xxx [, yyy [, zzz [, ... ]]]
	Assigns an array of integer or floating-point type. xxx,yyy,zzz should be written, for example, "A(10)". In this case, 11 integer type variables from A(0) to A(10) are allocated. In the case of a floating-point array, it should be written as "A#(10)". Multi-dimensional arrays can also be declared.
DO WHILE x|x#
LOOP
	If x or x# is non-zero, the statements from DO to LOOP are executed repeatedly.
DO UNTIL x|x#
LOOP
	If x or x# is 0, repeats the statements from the DO statement to the LOOP statement.
DO
LOOP WHILE x|x#
	Executes the statements from the DO statement through the LOOP statement and repeats if x or x# is non-zero.
DO
LOOP UNTIL x|x#
	Executes statements from the DO statement through the LOOP statement and repeats if x or x# is 0.
DRAWCOUNT x
	Specifies the DRAWCOUNT value, see DRAWCOUNT() function for DRAWCOUNT value.
END
	Stops the BASIC program.
EXEC x[,y[,z[...]]]
	Execute machine language. However, x, y, z are 32-bit integer values for Type Z and Type M, and 16-bit integer values for Type P.
FOR x=yyyy TO zzz [ STEP www ].
NEXT
	Assign the result of the calculation indicated by yyyy to x, and repeat the statements up to the next NEXT statement until the value of x is zzzz. Each time it is repeated, the value of x is incremented by www (or by 1 if omitted). Note that nothing is written after "NEXT".
GOSUB xxx [, yyy [, zzz [, ... ]]]
	Memorize the current execution position and move to line xxx (or label). yyyy, zzz, etc. are arguments that are passed on to the subroutine (see the ARGS() function).
GOTO xxx
	Go to line xxx (or label).
IF x|x# THEN yyy [ ELSE zzz ].
	If x is non-zero, execute yyyy; if x is zero, execute zzzz. yyyy and zzzz can be written with multiple statements separated by ":".
IF x|x# THEN
xxx
[ELSEIF y|y# THEN
yyy]
[ELSE
zzz]
ENDIF
	Execute xxx when x or x# is non-zero, yyyy otherwise and y or y# is non-zero (if described), zzzz otherwise. ELSEIF statements can be multiple. Note that on each line, do not put anything after the THEN statement.
LABEL xxx
	Register a jump destination for GOTO/GOSUB. xxx is a string of up to 6 alphanumeric characters.
[LET] x=yyyy
	Assign the result of the calculation indicated by y to x (an integer variable). LET" may be omitted.
[LET] x#=yyyy
	Assign the result of the calculation indicated by y to x (a floating-point variable). LET" may be omitted.
[LET] x$=yyyy
	The string (or concatenation result; the concatenation operator is "+") indicated by yyyy is assigned to x$. LET" may be omitted.
MUSIC x$[,y].
	Plays background music. For details, see <MUSIC> below. y=1 for Type M, y=2 for right side, y=3 for left side, or both when omitted.
PLAYWAVE x$[,y].
	Plays a WAVE file for music (specified by x$ as the file name) in stereo or monaural format for Type M (monaural only for Type Z) with a bit length of 8 and a sampling frequency of 15700 Hz. 16000 If y is specified, playback starts from the specified point (if you want to play from the first second, specify 15700). x$ is a zero-length string, which stops the currently playing music.
PALETTE n,r,g,b
	Palette specification.
PCG x,y,z
	Changes the display character for characters whose ASCII code is x. y,z are character data. See <PCG> below for details.
POKE x,y
	Writes the value (1-byte value) indicated by y to the physical address indicated by x.
POKE16 x,y
	Writes the value indicated by y (16-bit value) to the physical address indicated by x. Note that if x is an odd value, the exception stops.
POKE32 x,y
	Writes the value indicated by y (32-bit value) to the physical address indicated by x. Note that if x is not a multiple of 4, the exception stops.
PRINT [ x or x$ or x# [ , or; [ y or y$ or y# [ ... ]]]]
	Prints a whole number or string on the display. If ";" is used, the next display follows. If "," is used, the display is separated by 10 characters. If neither is used, the next display is on a different line.
REM xxx
	Nothing is executed. Used to insert comment text.
RESTORE xxx
	Specifies the starting position for reading DATA, where xxx is a line number or label.
RETURN
	Moves to the next statement after the last GOSUB statement. A return value may be specified. In this case, the return value can be obtained with the GOSUB() function.
SCROLL x,y
	Moves the screen horizontally or vertically (or diagonally). The direction and size of the movement are specified by x and y as the degree of horizontal movement and vertical movement, respectively.
SOUND xxx[,y].
	Plays a sound effect. For details, see <SOUND> below. xxx is a line number or label. y=1 for Type M, y=2 for right side, y=3 for left side, or both if omitted.
USEPCG [x].
	Use or deactivate PCG. x=0 to deactivate, x=1 to use, x=2 to reset the character. x omitted is the same as x=1.
USEVAR xxx [, yyy [, zzz [, ... ]]]
	Allows variable names of up to 6 characters in alphanumeric and underscore (_) (even longer names are allowed in Type P). Long variable names such as xxx, yyy, etc. can be used after this statement.
VAR xxx [, yyy [, zzz [, ... ]]]
	Specifies local variables to be used in the subroutine. xxx, yyy, etc. can be specified by A-Z alphabetical characters or variable names.
WAIT x
	Stops program execution for the time indicated by x. If x is 60, the program stops for about 1 second.
WHILE x|x#
WEND
	If x or x# is non-zero, the statements from WHILE to WEND are executed repeatedly.
WIDTH x[,y].
	Specifies the width of the character display in characters. x can be 30, 36, 40, 48, or 80; for Type P, the range is 1-40. If y=1, the display is vertical; if y=2, the display is horizontal (Type P only).

<Integer type function>
Hereinafter, x, y, z refer to integer values, x#, y#, z# refer to real values, and x$, y$, z$ refer to strings. [ ] indicates that the function is optional.

ABS(x)
	Returns the absolute value of x.
ARGS(x)
	In a subroutine, retrieves the x-th argument passed to GOSUB or a method as an integer value. However, if
		ARGS(0) returns the number of arguments.
		ARGS(-1) returns a pointer to the array that contains the previous argument.
		ARGS(-2) returns a pointer to an object if used in a class.
ASC(x$)
	Returns the ASCII code of the first character of a string.
CREAD()
	Reads data (8-bit integer value) one by one after the DATA statement. See also READ() function.
DRAWCOUNT()
	Obtains the DRAWCOUNT value, which is a 16-bit integer value that increases by 1 every 1/60th of a second.
GOSUB(xxx [, y [, z [, ... ]]])
	Same as the GOSUB instruction, but with a return value (see RETURN). xxx is a label or line number. yyyy, zzz, etc. are arguments that are passed on to the subroutine (see ARGS() function).
INKEY([x])
	If x is not specified, returns the ASCII value of the currently pressed key. If x is specified with an ASCII value, returns whether the key is pressed or not. invalid for Type P.
INT(x#)
	Converts the real value x# to an integer and returns it.
KEYS([x])
	Obtains the key input. x values are as follows. if x is not specified, x=63 is equivalent.
		KEYUP: 1
		KEYDOWN: 2
		KEYLEFT: 4
		KEYRIGHT: 8
		KEYSTART: 16
		KEYFIRE: 32
	Note that using this function on Type Z will disable keyboard-based functions such as INKEY interrupt and READKEY(), etc. This is not the case on Type M.
LEN(x$)
	Returns the length of the string.
MUSIC()
	Returns the number of BGM plays remaining.
NOT(x)
	Returns 1 if x=0, 0 otherwise.
PEEK(x)
	Reads 1 byte from the physical address indicated by x and returns it.
PEEK16(x)
	Reads 2 bytes from the physical address indicated by x and returns it as a 16-bit value; note that if x is an odd number, the exception stops.
PEEK32(x)
	Reads 4 bytes from the physical address indicated by x and returns a 32-bit value; note that if x is not a multiple of 4, the exception stops.
PLAYWAVE([x])
	If x is not specified or 0 is specified, returns the number of samplings remaining in the currently playing WAVE file; if 1 is specified, returns the sampling number currently playing; if 2 is specified, returns the total number of samplings in the WAVE file. If 2 is specified, the total sampling number of the WAVE file is returned.
READ()
	Reads data (32-bit integer value) one by one after the DATA statement. See also the CREAD() function.
READKEY()
	Reads a character from the keyboard buffer and returns it. Returns 0 if the buffer is empty. The return value is a 24-bit integer.
		bits 0-7 : ASCII code
		bits 8-15 : Virtual key code
		bits 16-23 : Shift key press status.
		             From highest to lowest <0><CAPSLK><NUMLK><SCRLK><Win><ALT><CTRL><SHIFT>.
RND()
	Return a pseudo-random number from 0 to 32767.
SGN(x)
	Returns the sign (-1, 0, or 1) of x.
STRNCMP(x$,y$,z)
	Compares z characters in two strings and returns the result. 0 if they are the same string.
TVRAM([x])
	Returns the xth content of video RAM as a byte value; if x is omitted, the physical address of the start of video RAM is returned.
VAL(x$)
	Returns the value of x$ as a decimal or hexadecimal string as an integer value.

<Floating point type function>
ACOS#(x#)
	Returns the inverse cosine of x# as a real value.
ARGS#(x)
	Retrieves the x-th argument passed to GOSUB or method in a subroutine as a real value.
ASIN#(x#)
	Returns the inverse sine of x# as a real value.
ATAN#(x#)
	Returns the inverse tangent of x# as a real value.
ATAN2#(y#,x#)
	Returns the inverse tangent of y#/x# as a real number.
CEIL#(x#)
	Returns the smallest integer greater than or equal to x# as a real number.
COS#(x#)
	Returns the cosine of x# as a real number.
COSH#(x#)
	Returns the hyperbolic cosine of x# as a real number.
EXP#(x#)
	Returns the real exponential value of x# with base e.
FABS#(x#)
	Returns the absolute value of x# as a real number.
FLOAT#(x)
	Converts an integer value x to a floating-point real value and returns it.
FLOOR#(x#)
	Returns the largest integer less than or equal to x# as a real number.
FMOD#(x#,y#)
	Returns the remainder of x# divided by y# as a real number.
GOSUB#(xxx [, y [, z [, ... ]]])
	Same as the GOSUB instruction, but returns a return value (see RETURN). xxx is a label or line number. yyyy, zzz, etc. are arguments that are passed on to the subroutine (see ARGS() function).
LOG#(x#)
	Returns the natural logarithm of x# as a real number.
LOG10#(x#)
	Returns the ordinary logarithm of x# as a real number.
MODF#(x#)
	Returns the fractional part of x# as a real number.
NOT#(x#)
	Returns 1 if x# is 0, 0 otherwise.
PI#
	Returns 3.141593.
POW#(x#,y#)
	Returns the y# power of x# as a real number.
SIN#(x#)
	Returns the sine of x# as a real number.
SINH#(x#)
	Returns the hyperbolic sine of x# as a real number.
SQRT#(x#)
	Returns the square root of x# as a real number.
TAN#(x#)
	Returns the tangent of x# as a real number.
TANH#(x#)
	Returns the hyperbolic tangent of x# as a real number.
VAL#(x$)
	Returns the value of x$ as a decimal string with real value.

<String type function>
A$(x [,y]) etc.
	If the value of x is 0, the entire string is returned.
	If the value of x is positive, the string to the right of the position indicated by x is returned.
	If the value of x is negative, the x characters to the right of the string are returned.
	If y is specified, returns the string for y characters.
ARGS$(x)
	In a subroutine, retrieve the x-th argument passed to GOSUB or a method as a string.
CHR$(x)
	Returns the character whose ASCII code is x.
DEC$(x)
	Returns the value of x as a decimal string.
FLOAT$(x#)
	Returns the real value x# as a decimal string.
GOSUB$(xxx [, y [, z [, ... ]]])
	Same as the GOSUB instruction, but returns a string (see RETURN) where xxx is a label or line number. yyyy, zzz, etc. are arguments that are passed on to the subroutine (see ARGS() function).
HEX$(x [,y])
	Returns the value of x as a hexadecimal string; if y is specified, the string is y bytes long.
INPUT$()
	Enters the string input state and returns the string when input is completed (when Enter is pressed).
SPRINTF$(x$,y#)
	Returns the contents of real number y# as a string according to the format indicated by x$.
READ$()
	Reads the string data one by one after the DATA statement.

<Integer operator>
&x
	Address to store variable x (pointer)
-x
	Invert the sign
x + y
	Integer addition
x - y
	Integer subtraction
x * y
	Integer multiplication
x / y
	Integer Division
x % y
	Integer remainder
x >> y
	Shift x value y bits to the right
x << y
	Shift x value y bits left
x = y
	1 if two integer values are equal, 0 otherwise
x ! = y
	0 when two integer values are equal, 1 otherwise
x < y
	1 if x is less than y, 0 otherwise
x <= y
	1 if x is less than or equal to y, 0 otherwise
x > y
	1 if x is greater than y, 0 otherwise
x >= y
	1 if x is greater than or equal to y, 0 otherwise
x AND y
	Bitwise AND of the values of x and y (note that this is not a logical conjunction)
x OR y
	Bitwise OR of the values of x and y
x XOR y
	Bitwise XOR of the values of x and y

Note that the order of precedence for integer operators is from highest to lowest as follows

+ - (unary operator) &
* / % (unary operator)
+ - (addition/subtraction)
<< >>
< <= > >= !
= ! = !
XOR
AND
OR

<String operators>
x$ + y$
	String concatenation

<Floating point operators>
-x#
	Invert sign
x# + y#
	Real number addition
x# - y#
	Real subtraction
x# * y#
	Real number multiplication
x# / y#
	Real division
x# = y#
	1 if two real numbers are equal, 0 otherwise
x# ! = y#
	0 if two real numbers are equal, 1 otherwise
1 if x# < y#
	1 if x is less than y, 0 otherwise
1 if x# <= y#
	1 if x is less than or equal to y, 0 otherwise
1 if x# > y#
	1 if x is greater than y, 0 otherwise
1 if x# >= y#
	1 if x is greater than or equal to y, 0 otherwise
x# AND y#
	Logical conjunction of x and y values (note that this is not a bitwise AND)
x# OR y#
	Logical OR of the values of x and y (note that this is not a bitwise OR)

The order of precedence of the real number operators is from highest to lowest as follows

+ - (unary operator)
* / - (addition/subtraction)
+ - (addition/subtraction)
< <= > >= !
= ! = !
AND
OR

<Special Instructions and Functions>
IDLE
	Enters idle mode ("wait" assembly). CPU stops until interrupts such as video signal creation or timers are applied.
OPTION x[,y[,z ... ]]]
	Specify various options. For more information on options, see the section "Options" below.
SYSTEM x , y
	Set various system values. (See <SYSTEM> below.)
SYSTEM(x)
	Returns various system values as integer values. (See <SYSTEM VARIABLES>.)
SYSTEM$(x)
	Returns various system values as strings. (See <System Variables>.)

<Graphics Related Instructions and Functions>

BOXFILL [x1,y1],x2,y2[,c]
	Draws a rectangle with color c whose diagonal is at coordinates (x1,y1), (x2,y2).
CIRCLE [x,y],r[,c]
	Draw a circle of radius r and color c with center at coordinates (x,y).
CIRCLEFILL [x,y],r[,c]
	Draw a circle centered at the coordinate (x,y), with radius r and color c.
GCLS
	Clear screen.
GCOLOR c
	In each instruction, specify the color if c is omitted.
GPALETTE n,r,g,b
	Palette specification.
GPRINT [x,y],c,bc,s$
	Display string s$ at coordinates (x,y) with color c, bc: background color (no background color specified for negative numbers).
LINE [x1,y1],x2,y2[,c].
	Draw a line segment from coordinates (x1,y1) to (x2,y2) with color c.
POINT x,y
	Set the current graphic position.
PSET [x,y][,c]
	Draw a point at coordinate (x,y) with color c.
PUTBMP [x,y],m,n,bbb
	Draws a character (specified by bbb) of size m*n dots horizontally and vertically at coordinates (x,y). Simply arrange the color numbers in an array bmp of size m*n. However, the part with color 0 is treated as a transparent color. However, bbb is a label name or a pointer to the array.
USEGRAPHIC [x].
For Type M
	Use or disuse the graphic display. x=0 to disuse, x=1, 5, 9 to use, x=2, 6, 10 to clear the screen and palette, x=3, 7, 11 to reserve the graphic area but leave the display as a character display. However, if x=0, 4, or 8 is set while the graphic display is not used, the area is reserved. x=1 is the same as x=1 if x is omitted. However, if x is 0-3, Type-Z compatible graphics are used; if x is 4-7, standard graphics are used; if x is 8-11, wide graphics are used.
For Type Z
	Use or deactivate the graphic display. x=0 deactivates it, x=1 uses it, x=2 clears the screen and palette for use, and x=3 reserves the graphic area but leaves the display as a character display. If x is omitted, the value is the same as x=1.
In the case of Type P
	This instruction clears the screen. Both graphics and characters are always available. However, if x=2, the palette is also initialized.

GCOLOR(x,y)
	Returns the palette number of the palette currently being displayed at graphic coordinates (x,y).

<File Related Instructions and Functions>
Up to two files can be open at the same time.

FCLOSE [x].
	Closes a file. If there is an argument (x), the file specified by the file handle is closed.
FGET x,y
	Reads y bytes into the buffer (specified as an array in x). If called as a function, returns the number of bytes successfully read.
FILE x
	Specify the active file handle (1 or 2) in x.
FOPEN x$,y$[,z].
	Opens the file whose name is indicated by x$ in the mode indicated by y$. The number of files that can be opened simultaneously is limited to two. If called as a function, a file handle is returned.
		"r": Opens a file in read mode.
		"r+": Same as "r" but also writable.
		"w": Opens a file in write mode. If a file with the same name exists, the previous file is deleted.
		       If there is a file with the same name, the previous file is erased.
		"w+": Same as "w", but also readable.
		"a": Opens a file in write mode. If there is a file with the same name, the file is not deleted.
		       file with the same name, the file is not erased, but written from the end of the file.
		"a+": Same as "a", but the file can also be read.
	z is a file handle (1 or 2) to be assigned. If omitted, 1 is specified.
FPRINT [ x or x$ or x# [ , or; [ y or y$ or y# [ ... ]]]]
	Same as the PRINT instruction, but information is written to a file instead of to the screen.
FPUT x,y
	Writes y bytes of the buffer (specified as an array in x). If called as a function, returns the number of bytes successfully written.
FPUTC x
	Writes one byte of data indicated by x to the file. If called as a function, returns the number of bytes successfully written (1 or 0).
FREMOVE x$
	Deletes the file whose name is indicated by x$ from the SD card. If called as a function, returns whether the deletion succeeded (0) or failed (-1).
FSEEK x
	Moves to the file location indicated by x.
SETDIR x$
	Moves the current directory to x$. If called as a function, returns 0 on success, non-zero on error.
FEOF()
	Returns whether the current file position of the file opened with FOPEN has reached the end of the file. 1 indicates that the end has been reached, 0 indicates that the end has not been reached.
FGETC()
	Reads 1 byte from the file opened with FOPEN and returns it as an integer value. Returns -1 if the end of the file has been reached or the read fails.
FLEN()
	Returns the length of the file opened with FOPEN in bytes.
FSEEK()
	Returns the current file position of the file opened with FOPEN.
FINPUT$([x])
	Reads a string of the length indicated by x from the file opened with FOPEN; if x is omitted, the string is read to the end of the line (including line feed codes).
GETDIR$()
	Returns the current directory as a string.

<Timer Related Instructions and Functions>
There are two types of timers: normal timers and core timers. Normal timers are general-purpose timers that can be used to set speeds and change values. Core timers are special timers synchronized with the CPU clock and can be read but not set.

CORETIMER
	Sets the timing of interrupts using the core timer. Note that this does not change the value of the core timer. The frequency of the core timer is 95.45453 MHz for Type M, 57.27272 MHz for Type Z (53.693175 MHz when graphics are used), and 1 MHz for Type P.
USETIMER x
	Starts a timer. x specifies the speed of the timer in microseconds (values less than or equal to 175769).
TIMER x
	Sets the current timer value as a 32-bit integer (x).
CORETIMER()
	Returns the current core timer value as a 32-bit integer value.
TIMER()
	Returns the current value of the timer as a 32-bit integer.

<Interrupt instruction>
INTERRUPT xxx,yyy[,z1[,z2 ...]] ]]
	xxx specifies the type of interrupt, and yyy specifies the subroutine to be used for the interrupt. z1, z2, etc., when specified, become the arguments of the subroutine for the interrupt. Available interrupt types are as follows
		TIMER
			Timer interrupt. An interrupt is applied every time the timer value increases by 1.
		DRAWCOUNT
			Interrupts every 1/60th of a second.
		KEYS
			When the button press state changes. note that using this function on Type Z will disable keyboard functions such as INKEY interrupt, READKEY(), INKEY(), etc. On Type M, this is not the case.
		INKEY
			When keyboard is pressed, use with READKEY() function.
		MUSIC
			When music is played, interrupts when the last note is played.
		WAVE
			When WAVE file playback ends.
		CORETIMER
			When the core timer value matches the value set by the CORETIMER instruction.
INTERRUPT STOP xxx
	Stops interrupts, where xxx is the type of interrupt.

<MUSIC>
The MUSIC instruction specifies the data for BGM as a string. The format of the string conforms to ABC notation. However, not all notation can be used. The default values for keys, speed, etc. are as follows

Q: 1/4=90
L: 1/8
K: C

The number of notes that can be set at one time when playing background music is up to 31. If you want to play music beyond this limit, check the return value of the MUSIC() function and execute the next MUSIC instruction after the value becomes small enough.

Please refer to the attached "music.bas" file for a sample of how to use this function.

<SOUND>
The SOUND instruction specifies the data in the DATA column by line number or label. If the next SOUND instruction is executed before the previous sound effect finishes, playback of the previous sound effect stops and a new sound effect is immediately played.

The DATA column represents the replacement sound as a 32-bit integer value. The lower 16 bits of this integer value specify the frequency; 2048 corresponds to 440 Hz (the sound of La). The larger the value, the lower the note. The upper 16 bits are the length of the note; 1 corresponds to 1/60th of a second. Finally, a value of 65535 or less specifies the number of times the sound effect is repeated. The number of these data should not exceed 32.

Please refer to the attached "sound.bas" file for a sample of how to use this function.

<PCG> PCG (Programmable Character Generator)
PCG (Programmable Character Generator) allows you to specify a font for each ASCII code and display it as pseudo-graphics. To use this function, first specify the font in the

USEPCG

to use the PCG statement. To change the font, use the PCG statement

PCG 0x80,0x80402010,0x08040201

using PCG statements like PCG 0x80,0x80402010,0x08040201. In this example, the font is set for characters with ASCII code 0x80, which will display a backslash-like symbol (a diagonal line from upper left to lower right).

USEPCG 0

If you want to use PCG again, use USEPCG 0. If you want to use PCG again, use

USEPCG

to use PCG again. The font data set earlier will be restored. If you want to discard the previously set font data and start using PCG again, set

USEPCG 2

If you want to discard the previously set font data and start using PCG, please set USEPCG 2.

<System Variables>
Various system information can be exchanged using the SYSTEM function and SYSTEM statements.

SYSTEM$(0)
	Returns the MachiKania version string, "Zoea", etc.
SYSTEM$(1)
	Returns the MachiKania version string, "1.2", etc.
SYSTEM$(2)
	Return BASIC version string, "KM-1208", etc.
SYSTEM$(3)
	Returns the name of the currently executing HEX file, e.g., "ZOEA.HEX".
SYSTEM(4)
	Returns the clock frequency of the CPU currently running.
SYSTEM(20)
	Returns character display width.
SYSTEM(21)
	Returns character display height.
SYSTEM(22)
	Returns the graphic display width.
SYSTEM(23)
	Return graphic display width.
SYSTEM(24)
	Return the specified color for the character display.
SYSTEM(25)
	Returns the specified color for the graphic display.
SYSTEM(26)
	Returns the current X position of the character display.
SYSTEM(27)
	Returns the current Y position of the character display.
SYSTEM(28)
	Returns the current X position of the graphic display.
SYSTEM(29)
	Returns the current Y position of the graphic display.
SYSTEM(40)
	Returns whether the PS/2 keyboard is in use.
SYSTEM(41)
	Returns the PS/2 keyboard information, vkey.
SYSTEM(42)
	Return PS/2 keyboard information, lockkey.
SYSTEM(43)
	PS/2 keyboard information, keytype is returned.
SYSTEM(100)
	Returns pointer to variable storage area (g_var_mem).
SYSTEM(101)
	Return a pointer to the random number seed.
SYSTEM(102)
	Returns a pointer to the character display area (TVRAM).
SYSTEM(103)
	Returns a pointer to the font area.
SYSTEM(104)
	Returns a pointer to the PCG font area.
SYSTEM(105)
	Returns a pointer to the graphic display area.
SYSTEM 200,x
	Stops (when x is 0) or starts (when x is non-zero) the display.

<Input/output commands and functions>
Input/output functions are available for Type M and Type P.

ANALOG(x)
	For Type M, returns the analog input value (10-bit value; value from 0-1023) of the xth bit from the lower part of PORTB. Type P returns the analog input value of GP26-29 (12-bit value; 0-4095). However, GP26 is specified for x=0, 13, 26; GP27 for x=1, 14, 27; GP28 for x=2, 15, 28; GP29 for x=3, 16, 29.
IN(x)
	Returns the input value (1-bit value; 1 or 0) of the xth bit from the lower part of the specified I/O port. However, when x=16, 17, or 18, PORTE5, 6, or 7 is specified, respectively. The input is pulled up inside the PIC.
IN8H()
	Returns the input value (8-bit value) of the upper 8 bits of PORTB for Type M and the specified I/O port for Type P. The input is pulled up inside the PIC.
IN8L()
	Returns the input value (8-bit value) of the lower 8 bits of the specified I/O port for Type M and Type P. The input is pulled up inside the PIC. The input is pulled up inside the PIC.
IN16()
	Returns the input value (16-bit value) of the specified I/O port for PORTB for Type M and for Type P. The input is pulled up inside the PIC. The input is pulled up inside the PIC.
PWM x[,y[,z]]
	PWM output; x specifies the duty ratio in the range 0-1000; y specifies the pulse frequency in Hz (1000 if omitted; valid values are 6-95454).
	For Type M, z=1 results in output to PORTD10, z=2 results in output to PORTD11; if z is omitted, PORTD10.
	For Type P, z=1, 2, and 3, output to the specified PWM1, PWM2, and PWM3, respectively.
SERIAL x[,y[,z]]
	Starts serial communication. x specifies the baud rate (to terminate use of serial communication, specify x=0). y=0 for no parity, y=1 for even parity, y=2 for odd parity, y=3 for no 9-bit parity. If y is omitted, it is the same as If y is omitted, y=0. z specifies the number of characters in the receive buffer; if z is omitted, a buffer large enough to guarantee continuous reception for 1/60th of a second is reserved.
SERIALIN([x])
	Receive one character in serial communication. If x=1, the number of characters in the receive buffer is returned. In case of 8-bit reception with parity, if a parity error occurs, a value of 0x100 or higher is returned.
SERIALOUT x
	Transmits a single character in serial communication.
OUT x,y
	Outputs the value indicated by y (1-bit value; 1 or 0) to the xth bit from the lower part of the specified I/O port in PORTB for Type M and in Type P. Note that PORTE5, 6, and 7 are open drain outputs.
OUT8H x
	Outputs the value indicated by x (8-bit value) to the upper 8 bits of PORTB for Type M and to the specified I/O port for Type P.
OUT8L x
	Outputs the value (8-bit value) indicated by "x" to the lower 8 bits of the specified I/O port for PORTB in Type M and Type P.
OUT16 x
	Outputs the value indicated by x (16-bit value) to the PORTB for Type M or to the specified I/O port for Type P.
I2C [x].
	Starts I2C use in master mode. x specifies the number of clocks in kHz (valid values are 12-3409). If omitted, x=100.
I2CWRITE x[,y[,z[, ... ]]
	Performs I2C fixed-length transmission. x is the 7-bit slave address. y, z, etc. are optional transmission codes, specified as byte values. Note that in the case of Type P, if y is not specified, no communication takes place at all.
I2CREAD(x[,y[,z[, ... ]])
	Receive 1 byte after I2C fixed length transmission. x is the 7-bit slave address. y, z, etc. are optional transmission codes, specified as byte values. Returns an 8-bit value on success, -1 on error. Returns -1 in case of error.
I2CWRITEDATA x,y,z1[,z2[,z3...]]
	Performs I2C multi-byte transmission. x is the 7-bit slave address, y is a pointer to the buffer containing the contents to be transmitted, z1 is the number of bytes in the buffer, z2, z3, etc. are optional transmission codes, these byte values are transmitted first, then the contents of buffer y transmitted over z1 bytes.
I2CREADDATA x,y,z1[,z2[,z3...]]
	Performs I2C multi-byte reception. x is the 7-bit slave address, y is a pointer to the buffer to store the contents to be received, z1 is the number of bytes to be received, z2, z3, etc. are optional transmission codes, these byte values are transmitted first, followed by z1 bytes of data to be received and sent to the buffer. data is received and stored in buffer y.
I2CERROR()
	Returns a non-zero value if there was an error in the previous I2C transmission/reception, otherwise returns 0.
SPI x[,y[,z1[,z2]]]
	Starts SPI usage in master mode. x specifies the number of clocks in kHz (valid values are 93-47727). y specifies the number of bits in one word in 8/16/32 (8 if omitted). z1 specifies how to handle SPI clock (0 if omitted). ). z1 specifies how to handle the SPI clock (0 if omitted). For details, see below. z2 specifies which port is used for the CS line.
	In the case of Type M, if z2 is omitted, it is 0x39 (PORTD9). If other ports are used, for example, 0x15 for PORTB5 and 0x13 for PORTB3.
	For Type P, if z2 is omitted, 3 (GP3). If other ports are used, for example, 4 for GP4 (I/O bit 4) and 27 or 14 for GP27 (I/O bit 14).
		z1=0: Low when idle and data changes to Low (CKP=0,CKE=1; CPOL=0,CPHA=0)
		z1=1: Low when idle, data changes to high (CKP=0,CKE=0; CPOL=0,CPHA=1)
		z1=2: "H" when idle, data changes to "H" (CKP=1,CKE=1; CPOL=1,CPHA=1)
		z1=3: High when idle, data changes to low (CKP=1,CKE=0; CPOL=1,CPHA=0)
SPIWRITE x[,y[,z[, ... ]]
	Performs SPI fixed-length transmission. x, y, z, etc. are transmission codes.
SPIREAD([x[,y[,z[, ... ]])
	Receive and return one word after SPI fixed-length transmission (optional). x, y, z, etc. are codes to be sent before reception.
SPIWRITEDATA x,y[,z1[,z2[,z3...]]]
	Performs SPI multi-word transmission. x is a pointer to a buffer containing the contents to be transmitted. y is the number of words in the buffer. z1, z2, z3, etc. are optional transmission codes, which are transmitted first, followed by the contents of buffer x over y words.
SPIREADDATA x,y[,z1[,z2[,z3...]]]
	Performs SPI multi-word reception. x is a pointer to the buffer to store the contents to be received. y is the number of words to be received. z1, z2, z3, etc. are optional transmission codes, which are transmitted first, followed by the reception of y words of data to be stored in buffer x.
SPISWAPDATA x,y[,z1[,z2[,z3...]]]
	SPI multi-word send/receive. x is a pointer to the buffer that stores the contents to be sent/received. y is the number of words to be sent/received. z1, z2, z3, etc. are optional transmission codes, which are sent first. Then, after sending the contents of buffer x, data is received and stored back into buffer x. This operation is repeated over y words.

<Option>
Type Z and Type M allow various options to be specified at compile-time or run-time using the OPTION statement. The following options are available

OPTION NOLINENUM
	Do not insert a line numbering instruction at compile time. This option is expected to reduce program size and increase execution speed. However, if an error occurs, it will not be clear which line the error occurred on.
OPTION FASTFIELD
	When two or more classes are used and there are no duplicate public field names, this option speeds up field access. However, it is advisable to make sure that there are no errors in the BASIC code before using this function, since it may not cause an error if a field of a nonexistent object is accessed. If only one class is used, this option is effective even if it is not specified.
OPTION CLASSCODE
	After this option, you can write a code that describes the class. However, the file name must be saved as "classname.BAS". Using this feature, code that uses only one class can be contained in a single file. This is useful for class development.

<Functions Related to Classes and Objects>
For details on how to use classes and objects, please refer to class.txt. The following are related instructions and functions.

USECLASS x[,y[,z[, ... ]]]
	Declares the use of a class. x,y,z, etc., is the class name up to 6 alphanumeric characters (Type P allows up to 8 characters).
FIELD [PUBLIC] x[,y[,z[, ... ]]]
	Declares a public field in the class file. PUBLIC" can be omitted. x,y,z, etc. are field names of up to 6 alphanumeric characters (long names are allowed in Type P).
FIELD PRIVATE x[,y[,z[, ... ]]]
	Declares a private field in the class file. x,y,z, etc. are field names up to 6 alphanumeric characters (long names are also acceptable for Type P).
STATIC [PUBLIC] x[,y[,z[, ... ]]]
	Declares a public static variable in the class file. PUBLIC" may be omitted.
STATIC PRIVATE x[,y[,z[, ... ]]]
	Declares a private static variable in the class file.
METHOD x
	Declares a method in the class file. x is the name of the method, up to 6 alphanumeric characters (Type P allows longer names).
NEW(x[,y[,z[, ... ]]])
	Creates a class object and returns a pointer to the object. x is the class name. y, z, etc. are arguments used when there is a constructor.
DELETE x[,y[,z[, ... ]]]
	Destroys the created object. x,y,z, etc. are the names of variables to store the object.
CALL x
	Calls the method of the object specified by x. CALL" can be omitted.

<Hints>
Since MachiKania ver 1.2, the RETURN statement can be used in the middle of the FOR-NEXT loop, WHILE-WEND loop, and DO-LOOP loop. However, jumping outside the loop with the GOTO statement will cause unexpected results (e.g., equipment reset). It is also possible to use the GOSUB statement to call a subroutine or nest another loop.

ON GOTO minutes and ON GOSUB statements are not supported. However, it is possible to cause similar behavior by writing, for example, the following
 GOSUB 10000+A
 ....
 10000 PRINT "A=0" : RETURN
 10001 PRINT "A=1" : RETURN
 10002 PRINT "A=2" : RETURN

If strings are handled consecutively in a line, an error message "String too complexed" may appear and the program may stop. In this case, try using a separate line for each string instruction, or try dividing the string-related operations into several steps, one line for each.

Be careful when accessing global variables in interrupt functions. If a variable of the same name is specified as a VAR in one of the subroutines and is also used as a local variable, depending on when the interrupt is triggered, the value of the variable may or may not belong to the global or local variable. Therefore, if you want to handle a global variable in an interrupt function, do not specify a variable of the same name as a VAR.

<Version history>
KM-1501 Released in October 2022.
　The NOT#() function was added.
　Fixed a bug that prevented compiling when using another class in a class.
　Fixed a bug in static function calls of the class.
　Allow assignment of strings and arrays to object fields
　Fixed a bug that WAVE files stop playing after a certain period of time
　Allows use of WAIT, DELAYMS, and DELAYUS statements during interrupts
KM-1500 Released in August 2022.
KM-1303 Released in May 2019.
　KM-1303 Released in May 2019. -Added timer functions (USETIMER, TIMER, CORETIMER statements and TIMER(), CORETIMER() functions).
　Interrupt function (INTERRUPT statement) is added.
　An option function (OPTION statement) is added.
　Idle function (IDLE statement) is added.
　The READKEY() function is added.
　The EXEC() function was added.
　Under score can be used in addition to alphanumeric characters in variable names.
　Fixed a display bug when using commas in PRINT.
KM-1302, released in March 2019.
　∙ Support for object-oriented programming.
　∙Allowed to get the number of arguments in args(0).
　・Added POKE16, POKE32, PEEK16(), PEEK32()
　Added & operator.
　∙ Added GETDIR$() function and SETDIR statement
∙ KM-1301 released December 2018.
　-I2C functionality is included.
　∙ SPI functionality is included.
　∙ Fixed a bug that prevented variables with long names from being used as the 5th argument of PUTBMP
-KM-1300 Published August 2018.
